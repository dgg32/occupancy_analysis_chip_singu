#!/usr/bin/env python3

# Import Modules
import sys
import os
import re
import json
import numpy as np
np.set_printoptions(precision=4, suppress=True)  # for test only
# import json ## for test only
import struct
# Document Decription
''' A class to read and write the intensity file generated by
    BGISEQ sequencer basecaller.
'''

# Version and Date
PROG_VERSION = '0.8.1'
PROG_DATE = '2017-10-27'

# Usage
usage = '''

     Version %s  by Vincent Li  %s

     Usage: %s <intFile> >STDOUT
''' % (PROG_VERSION, PROG_DATE, os.path.basename(sys.argv[0]))

# Global Variable


#######################################################################
############################  BEGIN Class  ############################
#######################################################################
class _bundle(dict):
    """ A class like dict which can be accessed
        use . operater.
        Usage:
        newDict = _bundle({})
        newDict["day"] = 1 ## set value as dict
        print newDict.day ## got 1, access as class

        newDict.month = 2 ## set value as class

        del newDict.month ## delete pair as class
    """
    def __init__(self, *args, **kw):
        super(_bundle, self).__init__(*args, **kw)

    __getattr__ = dict.__getitem__
    __delattr__ = dict.__delitem__
    __setattr__ = dict.__setitem__


class IntensityBin(object):
    """
        A class to read and write basecall intensity
        file in *.int format.

        Updates:
        2017/02/09, Version 1, 9 metrics, 6 int codes.

        ATTRIBUTES: (from a file loaded correctly)
            self.metrics:
                IntFile:       Path of the intensity.
                Format:        Format of source file. Either 'int' or 'csv'.
                FovCol:        Column id of this FOV in slide. (optional)
                FOVRow:        Row id of this FOV in slide. (optional)
                Column:        Number of horizontal blocks.
                Row:           Number of vertical blocks.
                SpotNumber:    Total DNB number in the intensity file.
                Channels:      Name of all channels, in same order of IntsData.
                ChannelNumber: Number of channels.
                ChannelInts:   A dict contains intensities (1D array) by channels, like
                               {channel1: Ints1, channel2: Ints2}
                               **The intensities is a reference of IntsData.**
                ExtractOrder:  1D array of BlockId by extraction order in np.int format.
                Blocks:        A dict contains the detail information of each blocks.
                               key: block id
                               value: block information (see below "self.metrics.Blocks[blockId]")

                ******* Raw data read as structInfoList *******
                IntsData:           1D array of all intensity values in np.float16 format,
                                    the size should equal to SpotNumber * ChannelNumber.
                ChannelInfo:        1D array of the original value of channel information in
                                    np.float32 format. Need to be decode by intensityCode.
                CrossPointXY:       1D array of all coordinates of track cross, in np.float32
                                    format. Every 2 values repersent a point as (X, Y).
                                    The points is organized from left to right, from top to
                                    bottom.
                                    The size of array should be:
                                        2  *   (Column + 1) * (Row + 1) * ChannelNumber
                Background:         1D array contains the background value of each track
                                    cross points.
                                    The size of array should be:
                                        (Column + 1) * (Row + 1) * ChannelNumber
                BlockInfo:          1D array of the template information. Every 3 values
                                    repersent a block:
                                        (blockId, width, height)
                                    ** The width and height repersent DNB number
                                    *** The distance is from track to track which equal to DNB number + 3.
                                    The order of blocks is same as extraction order.
                BadSpots:           1D array of bad sport of every channels and a cross set of
                                    all channels in np.float32 format. (Even they should be int)
                NormalizationValue: 1D array of normalization value of clustering
                                    in np.float32 format.
                PhasingParameter:   1D array of phasing parameters in np.float32 foramt.
                ClusterParameter:   1D array of clusters parameters in np.float32 format.
                CrosstalkFactor:    1D array of channel wise crosstalk factor in np.float32 format.
                                    The size of array should be:
                                        4-color: 6, Combination(4, 2).
                                        2-color: 0, no exists this metric.

            self.metrics.Blocks[blockId]:
                BlockId:     Id of this block
                Column:      Column id of this block in FOV.
                Row:         Row id of this block in FOV.
                Width:       Number of horizontal DNBs.
                Height:      Number of vertical DNBs.
                Number:      Total number of DNBs.
                IntIndex:    Index of the first DNB in this block in IntsData array.
                             A 1D array of intensities can be extract:
                                self.metrics.IntsData[IntIndex : IntIndex + Number]
                             *This index repersent the first channels, the sencond
                              channel should be IntIndex + self.metrics.SpotNumber
                ChannelInts: A dict contains intensities by channels, like:
                                 {channel1: Ints1, channel2: Ints2}
                             The intensities is a 2D array as Height * Width
                             DNB can be accessed with [y][x] indexing.
                TrackCross:  A 2D array contains the coordinates of 4 track crosses.
                             Each cross contain 2 values as (X, Y).
                             The order of 4 track crosses is:
                                     0 ------ 1
                                     |        |
                                     |        |
                                     3 ------ 2
                Background:  A 1D array contains the background vaules of 4 track
                             crosses. The order is same as TrackCross.

        METHODS:
            TBD.
    """

    #  structure define
    structInfoList = [
        "IntsData",
        "ChannelInfo",
        "CrossPointXY",
        "Background",
        "BlockInfo",
        "BadSpots",
        "NormalizationValue",
        "PhasingParameter",
        "ClusterParameter",
        "CrosstalkFactor"
    ]

    intensityCode = [
        "A",  # 0    4-color
        "C",  # 1    4-color
        "G",  # 2    4-color
        "T",  # 3    4-color
        "H",  # 4    2-color, A and C
        "L",  # 5    2-color, A and T
    ]

    ## Other common variants
    INT_LEN = FLOAT_LEN = 4  # unsigned and sign are 4 bytes
    METRICS_INFO_LEN = INT_LEN * 3  # int + unsigned int + unsigned int
    FOV_CR_LEN = 3  # FOV is named as CXXXRXXX
    DNB_TO_TRACK = 2  # how many DNBs form the edge of block to track

    def __init__(self, fileName=None, enableWarn=True):
        # Initialization
        self.clear()

        # output metrics
        self.metricsInfo = _bundle({
            "BlockId": _bundle(size=1, func=self._fillBlockId, fmt="%d", byChannel=False),
            "DnbCol": _bundle(size=1, func=self._fillDnbCol, fmt="%d", byChannel=False),
            "DnbRow": _bundle(size=1, func=self._fillDnbRow, fmt="%d", byChannel=False),
            "Coords": _bundle(size=2, func=self._fillCoords, fmt="%.2f", byChannel=True, prefix=["X", "Y"]),
            "Ints": _bundle(size=1, func=self._fillInts, fmt="%.2f", byChannel=True),
            "Background": _bundle(size=1, func=None, fmt="%.2f", byChannel=True)
        })

        # load intensity if a file is given
        if fileName is not None:
            if fileName.endswith('int'):
                self.load(fileName, warn=enableWarn)
            elif fileName.endswith('int.csv'):
                self.loadCsv(fileName)
            else:
                raise RuntimeError("[ERROR] Unknown file format: %s" % fileName)

    def __str__(self):
        try:
            return json.dumps(self.metrics, indent=4, sort_keys=True, default=self._numpySerialzer)
        except NameError:
            import json
            return json.dumps(self.metrics, indent=4, sort_keys=True, default=self._numpySerialzer)

    def getBasename(self):
        ''' Return the basename of source Intensity file.
            ** If source is CSV, suffix .csv will be remove
            while loading.
            If not exists IntFile metrics, return None.
        '''
        if "IntFile" not in self.metrics:
            return None
        return os.path.basename(self.metrics.IntFile)

    def getDirname(self):
        ''' Return the dirname of source Intensity file.
            If not exists IntFile metrics, return PWD.
        '''
        if "IntFile" not in self.metrics or not os.path.dirname(self.metrics.IntFile):
            return os.getcwd()
        return os.path.dirname(self.metrics.IntFile)

    def _intp(self, stVal, edVal, factor):
        '''Interpolation of val between stVal and edVal,
           The factor from stVal to val is factor*(edVal - stVal)
           stVal  --------  val  --------  edVal
                  factor        1 - factor
        '''
        return stVal + factor * (edVal - stVal)

    def _bintp(self, values, factor1, factor2):
        ''' Bilinear Interpolation
            Calculate the X value according to
            4 corner values.
               --- [0] ------------|------ [1]
                |   |              |        |
                f2  | ------f1------        |
                |   |                       |
               ------              X        |
                    |                       |
                    |                       |
                   [3] ------------------- [2]
        '''
        return self._intp(self._intp(values[0], values[1], factor1), self._intp(values[3], values[2], factor1), factor2)

    def calColRow(self, bkInfo):
        ''' Find how many blocks in a column or row.
            Since the order of block id is from left to right.
            We just need to lookup the height of first row
            until we meet a block with different height.
            Block order:
              |  0   1   2   3   4   5   6   7   8   9 |
              | 10  11  12  13  14  15  16  17  18  19 |
            Return:
            (Column, Row)
        '''
        tmpDict = {int(bkInfo[x]): int(bkInfo[x+2]) for x in range(0, len(bkInfo), 3)}
        heightFirstRow = tmpDict[0]
        column = row = 1
        for b in sorted(tmpDict.keys()):
            if tmpDict[b] != heightFirstRow:
                column = b
                row = len(tmpDict) // b
                break
        return column, row

    def clear(self):
        ''' Clear loaded data '''
        self.metrics = _bundle()

    def _guessColRow(self, fileName):
        ''' Calculate the Row and Column of FOV
            according to the file name started with
            CXXXRXXX.
            Return a tuple with (FovCol, FovRow)
        '''
        base = os.path.basename(fileName)
        match = re.search(r'C(\d{%d})R(\d{%d})' % (self.FOV_CR_LEN, self.FOV_CR_LEN), base)
        if match:
            self.metrics.FovCol = int(match.group(1))
            self.metrics.FovRow = int(match.group(2))
            return self.metrics.FovCol, self.metrics.FovRow
        return 0, 0

    def _loadCrossPointXYByBlock(self, block):
        ''' Load Track Cross Point coordinates of specific
            block.
            Parameters:
            block: A bundle object of block information
            from self.metrics.Blocks[blockId]

            Return:
            same as block.
        '''
        mp = self.metrics
        if "CrossPointXY" not in mp:
            return
        for i, t in enumerate(mp.Channels):
            # the track is separated into N
            # parts according to channel number.
            # Calculate the index of current channel
            st = i * len(mp.CrossPointXY) // mp.ChannelNumber

            # Track crosses coordinates organized by rows,
            # 2 numbers for each point: (X, Y)
            # So the width of a row is 2 * [FOV Column + 1 (top-right corner)]
            # fidx is the index of top-left track cross
            # sidx is the index of bottom-left track cross
            fidx = block.Row*(mp.Column+1)*2 + block.Column*2 + st
            sidx = fidx + (mp.Column+1)*2
            # In C++ program the order is
            # top-left, top-right, bottom-right, bottom-left
            # Use same order below:
            block.TrackCross[t] = np.array([
                [mp.CrossPointXY[fidx], mp.CrossPointXY[fidx+1]],
                [mp.CrossPointXY[fidx+2], mp.CrossPointXY[fidx+3]],
                [mp.CrossPointXY[sidx+2], mp.CrossPointXY[sidx+3]],
                [mp.CrossPointXY[sidx], mp.CrossPointXY[sidx+1]]
            ])
        return block

    def _loadBackgroundByBlock(self, block):
        ''' Calculate the Background of 4 track cross point
            of specific block.
            Parameters:
            block: A bundle object of block information
                   from self.metrics.Blocks[blockId]

            Return:
            same as block.
        '''
        mp = self.metrics
        if "Background" not in mp:
            return
        for i, t in enumerate(mp.Channels):
            # Background value is organized by rows,
            # So the width of a row is FOV Column + 1 (top-right corner)
            st = i * len(mp.Background) // mp.ChannelNumber
            fidx = block.Row*(mp.Column+1) + block.Column + st
            sidx = fidx + mp.Column+1
            block.Background[t] = np.array([
                mp.Background[fidx],
                mp.Background[fidx+1],
                mp.Background[sidx+1],
                mp.Background[sidx]
            ])
        return block

    def dump_block_backgrounds(self):
        background_arr = np.zeros((100, 4))
        for i in range(100):
            background_arr[i, 0] = self.metrics.Blocks[i].Background.A.mean()
            background_arr[i, 1] = self.metrics.Blocks[i].Background.C.mean()
            background_arr[i, 2] = self.metrics.Blocks[i].Background.G.mean()
            background_arr[i, 3] = self.metrics.Blocks[i].Background.T.mean()
        return background_arr

    def _loadIntsDataByBlock(self, block):
        ''' Load the intensity of specific block.
            ** ChannelInts is a reference of IntsData.

            Parameters:
            block: A bundle object of block information
            from self.metrics.Blocks[blockId]

            Return:
            same as block.
        '''
        mp = self.metrics
        if "IntsData" not in mp:
            return
        for i, t in enumerate(mp.Channels):
            # add Channel intensity
            # reshape to 2D shape
            # can access specific DNB with IntsData[y][x]
            # *NOTE*: the ChannelInts is just a reference
            # of IntsData (a new View with different shape).
            # So changing this value will actually change the IntsData.
            st = block.IntIndex + i * len(mp.IntsData) // mp.ChannelNumber
            block.ChannelInts[t] = mp.IntsData[st: st+block.Number].reshape(block.Height, block.Width)
        return block

    def _loadBlockMetrics(self):
        ''' Calcualte the metrics by blocks.
            Return:
            A dict contains all blocks (self.metrics.Blocks)
        '''
        mp = self.metrics
        # skip adding block information if metrics is not exists
        if "BlockInfo" not in mp:
            return mp

        # Extraction Order
        mp.ExtractOrder = mp.BlockInfo[::3].astype(np.int)

        mp.Blocks = _bundle()
        intensityIndex = 0
        mp.Column, mp.Row = self.calColRow(mp.BlockInfo)

        ## FIXME: a quick fix for inconsistent of width, height and DNB number
        # self._fixBlockInfo()

        for bidx in range(0, len(mp.BlockInfo), 3):
            blockId = int(mp.BlockInfo[bidx])
            bkWidth = int(mp.BlockInfo[bidx+1]) - 3
            bkHeight = int(mp.BlockInfo[bidx+2]) - 3
            mp.Blocks[blockId] = _bundle({
                "BlockId": blockId,
                "Width": bkWidth,
                "Height": bkHeight,
                "Column": blockId % mp.Column,
                "Row": blockId // mp.Column,
                "Number": bkWidth * bkHeight,
                "IntIndex": intensityIndex,
                "TrackCross": _bundle(),
                "Background": _bundle(),
                "ChannelInts": _bundle()
            })

            # load Track Cross
            self._loadCrossPointXYByBlock(mp.Blocks[blockId])

            # load Background
            self._loadBackgroundByBlock(mp.Blocks[blockId])

            # load IntsData
            self._loadIntsDataByBlock(mp.Blocks[blockId])

            # update intensity index
            intensityIndex += mp.Blocks[blockId].Number

        mp.HorizontalDNB = sum([self.metrics.Blocks[x].Width +
                                (self.DNB_TO_TRACK + 1) for x in range(self.metrics.Column)]) - self.DNB_TO_TRACK - 1
        mp.VerticalDNB = sum([self.metrics.Blocks[x*self.metrics.Column].Height +
                              (self.DNB_TO_TRACK + 1) for x in range(self.metrics.Row)]) - self.DNB_TO_TRACK - 1
        return mp.Blocks

    def load(self, fileName, warn=True):
        ''' Load intensity data from a int file
            Return self.metrics
        '''
        # clear old data
        self.clear()

        # make a shortcut
        mp = self.metrics

        mp.IntFile = fileName
        mp.Format = "int"
        # guess Col and Row by file name
        self._guessColRow(fileName)

        with open(fileName, 'rb', 10000000) as fh:
            # load header
            # metrics number
            metricsNum = struct.unpack("I", fh.read(self.INT_LEN))[0]

            # Change metrics size
            if metricsNum > len(self.structInfoList):
                # intensity file is from a NEWER version than this program
                if warn == True:
                    pass
                    # print("New")
                    # print("[WARN] Intensity file %s with %d metrics, is newer than this program %d metrics.
                    # The last %d metric(s) can not be read correctly." % (fileName, metricsNum,
                    # len(self.structInfoList), metricsNum - len(self.structInfoList)), file=sys.stderr)
                # ignore the over head metrics
                metricsNum = len(self.structInfoList)
            elif metricsNum < len(self.structInfoList):
                # intensity file is from a OLDER version than this program
                if warn == True:
                    print("New")
                    # print("[WARN] Intensity file %s with %d metrics,
                    # is generated from an older version basecaller compare to this program (with %d metrics).
                    # The last %d metric(s) would be empty." % (fileName, metricsNum, len(self.structInfoList),
                    # len(self.structInfoList) - metricsNum), file=sys.stderr)
            # metricsNum -= 1 ## FIXME: This test only


            # load metrics
            metricsDesc = _bundle()
            for n in range(metricsNum):
                idx, count, offset = struct.unpack("iII", fh.read(self.METRICS_INFO_LEN))
                # print(idx, count, offset)
                metricsName = self.structInfoList[idx]
                if count != 0:
                    # count ==0 means not exist this metric
                    metricsDesc[metricsName] = _bundle(count=count, offset=offset)

            # extract info of metrics
            for m in metricsDesc:
                # the first one is intensities which is float16
                fh.seek(metricsDesc[m].offset)
                if m != "IntsData":
                    mp[m] = np.fromfile(fh, dtype=np.float32, count=metricsDesc[m].count)
                else:
                    # Intensity is saved as float16 format (s10e5)
                    # which can directly read by numpy
                    mp[m] = np.fromfile(fh, dtype=np.float16, count=metricsDesc[m].count)

            # DNB Number
            mp.SpotNumber = int(len(mp.IntsData) / metricsDesc.ChannelInfo.count)
            spotNum = mp.SpotNumber  # make a shortcut

            # channel intensity
            mp.ChannelInts = _bundle()
            mp.Channels = [self.intensityCode[int(x)] for x in mp.ChannelInfo]
            mp.ChannelNumber = len(mp.Channels)
            intP = 0
            for ch in mp.Channels:
                mp.ChannelInts[ch] = mp.IntsData[intP:intP+spotNum]
                intP += spotNum

            # block information
            self._loadBlockMetrics()
        # END open int file
        return self.metrics

    def loadCsv(self, fileName):
        ''' Load intensity data from a CSV file (*.int.csv)
            Return self.metrics
        '''
        # clear old data
        self.clear()

        # make a shortcut
        mp = self.metrics

        mp.IntFile = fileName[:-4]
        mp.Format = 'csv'
        # guess Col and Row by file name
        self._guessColRow(fileName)

        ## Channels
        mp.Channels = []

        with open(fileName, 'r', 100000000) as fh:
            section = []
            dataList = []
            for line in fh:
                info = line.strip().split(",")
                if line.startswith('#'):
                    if line.startswith('#array') or line.startswith('#dict'):
                        ## start of senction
                        section = info[1:]
                        dataList = []
                    else:
                        ## comments
                        continue
                elif line.startswith("\n"):
                    ## end of section
                    if section[0] == "Image":
                        for v in dataList:
                            if v[0] == "Channels":
                                mp.Channels = v[1:]
                                mp.ChannelNumber = len(mp.Channels)
                            elif v[0] == "Width" or v[0] == "Height":
                                mp[v[0]] = int(v[1])
                    elif section[0] in self.structInfoList:
                        tmpArr = np.array(dataList, dtype=np.float32)
                        ## TODO: use a better way to reshape
                        if section[0] == "CrossPointXY":
                            if section[0] not in mp:
                                mp.CrossPointXY = np.zeros(tmpArr.size * mp.ChannelNumber)
                            idx = mp.Channels.index(section[1]) * tmpArr.size
                            mp.CrossPointXY[idx:idx+tmpArr.size] = tmpArr.flatten()
                        elif section[0] == "BlockInfo":
                            mp.BlockInfo = tmpArr.flatten()
                    else:
                        continue

                else:
                    dataList.append(info)
        self._loadBlockMetrics()
        mp.SpotNumber = sum([x.Number for x in mp.Blocks.values()])

    def save(self, fileName):
        ''' Save current metrics to Intensity file. (*.int)
            Only save metrics in structInfoList.
            If a metrics not exists in self.metrics,
            the info will be save into head with 0 count.
        '''
        ## make a shortcut
        mp = self.metrics

        with open(fileName, "wb", 10000000) as fh:
            ## write metrics number
            metricsNum = len(self.structInfoList)
            fh.write(struct.pack("I", metricsNum))

            ## calculate offset
            headP = headSt = fh.tell()
            headLen = metricsNum * self.METRICS_INFO_LEN
            bodyP = bodySt = headSt + headLen
            for i, m in enumerate(self.structInfoList):
                if m in mp:
                    count = mp[m].size
                else:
                    ## empty metrics
                    count = 0

                ## write head
                fh.seek(headP)
                fh.write(struct.pack("iII", i, count, bodyP))
                headP = fh.tell()

                ## write body
                if m in mp:
                    fh.seek(bodyP)
                    mp[m].tofile(fh)
                    bodyP = fh.tell()
        return bodyP

    def getCoordsByBlock(self, blk):
        ''' Calculate all coordinates of specific block.
            Use numpy.linspace function to interpolate the
            coordinate of evary DNB.
            ~10X faster than calculating by DNBs with Python.

            1, Construct a 2D matrix including the tracks.
            2, Interpolate the first and last column by the
               (top-left, bottom-left) and (top-right, bottom-right)
               track cross points.
            3, Interpolate every row by the values on the
               first and last column.
        '''
        coordBuff = _bundle()
        ## create the coordinates matrix
        crossDisX = blk.Width + self.DNB_TO_TRACK * 2
        crossDisY = blk.Height + self.DNB_TO_TRACK * 2
        for ch in self.metrics.Channels:
            coordBuff[ch] = []
            ## 0: X  1: Y
            for w in range(2):
                coordBuff[ch].append(np.empty((crossDisY, crossDisX)))
                coordBuff[ch][w][:, 0] = np.linspace(blk.TrackCross[ch][0][w], blk.TrackCross[ch][3][w], crossDisY)
                coordBuff[ch][w][:, -1] = np.linspace(blk.TrackCross[ch][1][w], blk.TrackCross[ch][2][w], crossDisY)
                for r in range(crossDisY):
                    coordBuff[ch][w][r, :] = np.linspace(coordBuff[ch][w][r][0], coordBuff[ch][w][r][-1], crossDisX)
                coordBuff[ch][w] = coordBuff[ch][w][2:-2, 2:-2]
        return coordBuff

    def _fillBlockId(self, blk, out, skip=0):
        ''' Fill the array with blockId.
            Parameters:
            blk:  A bundle object of block information
                  from self.metrics.Blocks[blockId]
            out:  A np.ndarray object to fill the coordinates.
            skip: The number to shift from the first position of out.
        '''
        out[:] = blk.BlockId

    def _fillDnbRow(self, blk, out, skip=0):
        ''' Row id for each DNB,
            will be like:
                0 0 0 0 0 0
                1 1 1 1 1 1
                2 2 2 2 2 2
            in 1D array
            Parameters:
            blk:  A bundle object of block information
                  from self.metrics.Blocks[blockId]
            out:  A np.ndarray object to fill the coordinates.
            skip: The number to shift from the first position of out.
        '''
        out[:] = np.arange(blk.Height).repeat(blk.Width)

    def _fillDnbCol(self, blk, out, skip=0):
        ''' Col id for each DNB,
            will be like:
                0 1 2 3 4 5
                0 1 2 3 4 5
                0 1 2 3 4 5
            in 1D array
            Parameters:
            blk:  A bundle object of block information
                  from self.metrics.Blocks[blockId]
            out:  A np.ndarray object to fill the coordinates.
            skip: The number to shift from the first position of out.
        '''
        out[:] = np.tile(np.arange(blk.Width), blk.Height)

    def _fillCoords(self, blk, out, skip=0):
        ''' Calculate the coordinates of each DNB of specific block.
            Fill into a given np.ndarray object.
            Parameters:
            blk:  A bundle object of block information
                  from self.metrics.Blocks[blockId]
            out:  A np.ndarray object to fill the coordinates.
            skip: The number to shift from the first position of out.
        '''
        stepSize = len(out) // self.metrics.ChannelNumber
        coordBuff = self.getCoordsByBlock(blk)
        for i, ch in enumerate(self.metrics.Channels):
            ## X and Y
            for o in range(2):
                stIdx = i * stepSize + skip * blk.Number + o * blk.Number
                out[stIdx : stIdx+blk.Number] = coordBuff[ch][o].flatten()

    def _fillInts(self, blk, out, skip=0):
        ''' Extract the intensity of each DNB of specific block.
            Fill into a given np.ndarray object.
            Parameters:
            blk:  A bundle object of block information
                  from self.metrics.Blocks[blockId]
            out:  A np.ndarray object to fill the coordinates.
            skip: The number to shift from the first position of out.
        '''
        stepSize = len(out) // self.metrics.ChannelNumber
        for i, ch in enumerate(self.metrics.Channels):
            stIdx = i * stepSize + skip * blk.Number
            out[stIdx : stIdx+blk.Number] = blk.ChannelInts[ch].flatten()

    def getCrossPointByChannel(self):
        ''' Split the CrossPointXY metrics by channels
            and reshape to 2D array with (X, Y) for each row.
            Return:
            crossDict:
                key: channel
                value: A 2D array of cross point. shape: (N, 2)
                       Row: Number of cross point.
                       Col: coordinates as X, Y
        '''
        mp = self.metrics
        crossDict = {}
        for i,ch in enumerate(mp.Channels):
            num = len(mp.CrossPointXY) // mp.ChannelNumber
            st = i * num
            crossDict[ch] = mp.CrossPointXY[st:st+num].reshape(-1, 2)
        return crossDict

    def getMetricsByBlock(self, blk, metList=["BlockId", "DnbRow", "DnbCol", "Coords", "Ints"]):
        ''' Return a 2D array filled with specific metrics of given block. (np.float32)
            Each metrics with size of Size * SpotNumber in this block.
            Executable methods and attributes is defined in self.metricsInfo.
            Attributes and Methods:
                size: Slots of this metrics (per channel if byChannel is True), N means N * SpotNumber.
                fmt: Output format string. Specify the precision of float number.
                byChannel: Whether this metrics is byChannel. If True, the final size would be
                           Size * SpotNumber * ChannelNumber.
                prefix: The name displayed in header. (Start with "Channel_" if byChannel is True).
                func: The callable function to fill the values into a empty 1D array.
                    Parameters of func:
                        blk: Specific element in self.metrics.Blocks
                        out: 1D array which is a view of a part of the result array. The length should
                             match the size of this metrics.
                             if byChannel is False, length = size * SpotNumber
                             if byChannel is True, length = Sum(all size of metrics byChannel)
                        skip: How many slot need to be skip to reach the first position of this metrics.
                              (only apply if byChannel is True)
            Return:

        '''
        sizeCnt = 0
        channelShift = 0
        paraDict = {}
        for m in metList:
            if self.metricsInfo[m].byChannel == True:
                paraDict[m] = _bundle(start=sizeCnt*blk.Number, skip=channelShift)
                channelShift += self.metricsInfo[m].size
            else:
                paraDict[m] = _bundle(start=sizeCnt*blk.Number, skip=0)
                sizeCnt += self.metricsInfo[m].size

        data = np.empty(sizeCnt*blk.Number + channelShift * blk.Number * self.metrics.ChannelNumber, dtype=np.float32)
        for m in metList:
            if self.metricsInfo[m].byChannel == True:
                ed = paraDict[m].start + channelShift * blk.Number * self.metrics.ChannelNumber
            else:
                ed = paraDict[m].start + self.metricsInfo[m].size * blk.Number
            self.metricsInfo[m].func(blk, data[paraDict[m].start : ed], skip=paraDict[m].skip)

        return data.reshape(-1, blk.Number).T

    def dumpAll(self, fp, metList=["BlockId", "DnbRow", "DnbCol", "Coords", "Ints"], blockList=None, noheader=False, delimiter="\t"):
        ''' Dump specific into a file object.
            Parameters:
                metList:   A list of output metrics, defined in self.metricsInfo
                blockList: A list of all block id to display.
                noheader:  Do not show header if apply.
                delimiter: Delimiter of output text. "\t" by default.
                fp:        File object to output, file should be open in 'wb' mode.
                        In order to pack with PyInstaller, disable the default value
                        of fp. Use fp=sys.stdout.buffer to display the result on STDOUT.
        '''
        headerList = []
        fmtList = []
        byChannelList = []
        for m in metList:
            if m not in self.metricsInfo:
                raise RuntimeError("[ERROR] Not exists method to dump metrics: %s." % m)
            if self.metricsInfo[m].byChannel == False:
                headerList.append(m)
                fmtList.append(self.metricsInfo[m].fmt)
            else:
                byChannelList.append(m)
        for ch in self.metrics.Channels:
            for e in byChannelList:
                if "prefix" in self.metricsInfo[e]:
                    for p in self.metricsInfo[e].prefix:
                        headerList.append("%s_%s" % (ch, p))
                        fmtList.append(self.metricsInfo[e].fmt)
                else:
                    headerList.append("%s_%s" % (ch, e))
                    fmtList.append(self.metricsInfo[e].fmt)
        formatStr = delimiter.join(fmtList)
        if noheader == False:
            fp.write(np.compat.asbytes("#" + delimiter.join(headerList) + "\n"))

        ## write body
        if not blockList:
            blockList = self.metrics.ExtractOrder
        for b in blockList:
            blk = self.metrics.Blocks[b]
            blkData = self.getMetricsByBlock(blk, metList)
            try:
                np.savetxt(fp, blkData, fmt=formatStr)
            except:
                sys.stderr.close()
                return

    def dumpInts(self, fp, noheader=True, delimiter="\t"):
        ''' Dump the intensity value to binary file object by channels.
            Parameters:
                fp:        File object to output, file should be open in 'wb' mode.
                           In order to pack with PyInstaller, disable the default value
                           of fp. Use fp=sys.stdout.buffer to display the result on STDOUT.
                noheader:  Do not show header if apply.
                delimiter: Delimiter of output text. "\t" by default.
        '''
        if noheader == False:
            fp.write(np.compat.asbytes("#" + delimiter.join(self.metrics.Channels) + "\n"))
        np.savetxt(fp, self.metrics.IntsData.reshape(self.metrics.ChannelNumber, -1).T, delimiter=delimiter, fmt="%.3f")

    def getInt(self, blockId, channel, x, y):
        ''' Return the intensity of specific DNB by block, channel and coordinate'''
        return self.metrics.Blocks[blockId].ChannelInts[channel][y][x]

    def getDNB(self, blockId, x, y):
        ''' Get the detailed information of a DNB by block and coordinate.
            Parameters:
                blockId: The id of specific block
                x:       Column of this DNB in block.
                y:       Row of this DNB in block.
            Return:
                dnbInfo:
                    BlockId:    Block id of this DNB.
                    X:          Column of this DNB in block.
                    Y:          Row of this DNB in block.
                    Coords:     Coordinates of this DNB by channels.
                    Background: Background of this DNB by channels.
        '''
        f1 = x/(self.metrics.Blocks[blockId].Width + self.DNB_TO_TRACK * 2 - 1)
        f2 = y/(self.metrics.Blocks[blockId].Height + self.DNB_TO_TRACK * 2 - 1)

        dnbInfo = _bundle()
        dnbInfo.BlockId = blockId
        dnbInfo.X = x
        dnbInfo.Y = y
        dnbInfo.Ints = { ch: float(self.getInt(blockId, ch, x, y)) for ch in self.metrics.Channels }

        ## coordinates and background
        tc = self.metrics.Blocks[blockId].TrackCross
        bk = self.metrics.Blocks[blockId].Background
        dnbInfo.Coords = _bundle()
        dnbInfo.Background = _bundle()
        for ch in self.metrics.Channels:
            dnbInfo.Coords[ch] = [self._bintp([k[0] for k in tc[ch]], f1, f2), self._bintp([k[1] for k in tc[ch]], f1, f2)]
            dnbInfo.Background[ch] = self._bintp(bk[ch], f1, f2)
        return dnbInfo

    @staticmethod
    def _numpySerialzer(o):
        """ Serialize numpy types for json

        Parameters:
            o (object): any python object which fails to be serialized by json
        """
        if isinstance(o, np.ndarray):
            return "array(dtype=%s, shape=%s)" % (o.dtype, str(o.shape))
        else:
            raise TypeError("{} of type {} is not JSON serializable".format(repr(o), type(o)))


##########################################################################
############################  BEGIN Function  ############################
##########################################################################


######################################################################
############################  BEGIN Main  ############################
######################################################################
#################################
##
##   Main function of program.
##
#################################
def main():

    ######################### Phrase parameters #########################
    import argparse
    ArgParser = argparse.ArgumentParser(usage=usage)
    ArgParser.add_argument("--version", action="version", version=PROG_VERSION)
    ArgParser.add_argument("-s", "--show", action="store", dest="showMetrics", default=None, metavar="STR", help="Print specific metrics of intensity file. [%(default)s]")
    ArgParser.add_argument("-d", "--dump", action="store", dest="dumpMetrics", default="all", metavar="METRICS_LIST", help="Metrics which will be showed in file. Separated by comma. Avaliable Values: [BlockId, DnbRow, DnbCol, Coords, Ints] [%(default)s]")
    ArgParser.add_argument("-b", "--blocks", action="store", dest="blockListStr", default=None, metavar="STR_LIST", help="Block list to print, separated by comma. [%(default)s]")
    ArgParser.add_argument("-n", "--noheader", action="store_true", dest="noheader", default=False, help="Print DNB information without header. [%(default)s]")

    (para, args) = ArgParser.parse_known_args()

    if len(args) != 1:
        ArgParser.print_help()
        # print("\nERROR: The parameters number is not correct!", file=sys.stderr)
        print("\nERROR: The parameters number is not correct!")
        sys.exit(1)
    else:
        (intFile,) = args

    ############################# Main Body #############################
    ib = IntensityBin(intFile)
    ## show metrics
    if para.showMetrics:
        if para.showMetrics in ib.structInfoList:
            np.savetxt(sys.stdout.buffer, ib.metrics[para.showMetrics], fmt="%.2f")
    else:
        ## output blocks
        if para.blockListStr:
            blkList = list(map(int, para.blockListStr.split(",")))
        else:
            blkList = None

        ## output metrics
        if para.dumpMetrics == "all":
            showMetrics = ["BlockId", "DnbRow", "DnbCol", "Coords", "Ints"]
        else:
            showMetrics = para.dumpMetrics.strip().split(",")
        ib.dumpAll(fp=sys.stdout.buffer, blockList=blkList, noheader=para.noheader, metList=showMetrics)
    # print(ib)
    # print(json.dumps(ib.getDNB(11, 2, 6), indent=4, sort_keys=True))

#################################
##
##   Start the main program.
##
#################################
if __name__ == '__main__':
    main()

################## God's in his heaven, All's right with the world. ##################
