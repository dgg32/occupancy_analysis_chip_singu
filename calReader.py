
# Import Modules
import sys
import os
import numpy as np
import csv
np.set_printoptions(precision=4, suppress=True)  # for test only

# import json
# import pprint
# import cPickle as pickle

###### Document Decription
'''  '''

# Version and Date
PROG_VERSION = '0.5.0'
PROG_DATE = '2017-10-11'

# Usage
usage = '''

     Version %s  by Alexander Jorjorian  %s

     Usage: %s <calFile> >STDOUT
''' % (PROG_VERSION, PROG_DATE, os.path.basename(sys.argv[0]))

######## Global Variable


#######################################################################
############################  BEGIN Class  ############################
#######################################################################
def scores2discordance(score_counts):
    """

    :param score_counts:
        list of counts where index is the q score for that count
    :return:
    """
    counts_total = float(sum(score_counts))
    if not counts_total: return 0.0
    # convert quality score to discordance rate (10^(-q/10) = rate)
    rate_list = [10 ** (-score / 10.0) for score, score_count in enumerate(score_counts)]
    weight_list = [score_count / counts_total for score_count in score_counts]
    discordance = round(sum([weight * rate for weight, rate in zip(weight_list, rate_list)]) * 100.0, 4)
    return discordance


class Cal(object):
    """ API to read/write cal file generated by BGISEQ basecaller (V0.1 framework).
        Load cal into memory, do some modification and write back to new/original
        cal file.
        Attributes:
            calFile:     Full file path of the cal file.
            fov:         FOV Id of the cal file. (CXXXRXXX)
            number:      Number of DNBs in cal file.
            totalCycle:  Total cycle number in cal file.
            qual:        A dict of the quality of each DNB by cycle
                key:         cycle id. 1-based.
                value:       np.uint8 array of qualities. 0 to 33. size = self.number
            basesDigit:  A dict of bases in integer format of each DNB by cycle,
                         ASCII values of A,C,G,T,N.
                key:         cycle id. 1-based.
                value:       np.uint8 array of bases. see self._baseASCII for the range of values.
            bases:       A dict of bases in np.bytes_ format of each DNB by cycle.
                key:         cycle id. 1-based.
                value:       np.bytes_ array of bases. A/C/G/T/N.
            ** bases is a view of basesDigit. So modify the charater of bases will also change
               basesDigit.
        Methods:
            clear():                      Clear current loaded data.
            load(filename):               Load bases and qualities from cal file.
            save(filename):               Dump bases and qualities to cal file.
            listAll():                    List all bases and qualities by cycle.
            get(cycle, idx):              Get the base and quality by cycle and index.
            setBase(cycle, idx, base):    Set the base of specific DNB by cycle and index.
            setQual(cycle, idx, qual):    Set the quality of specific DNB by cycle and index.
            writefq(filename, idPrefix):  Save the base and quality as FASTQ format. Compressing
                                          to gzip format if filename end with .gz.

    """

    INT_LEN = 4
    BASES_MASK = 64
    FOV_CR_LEN = 3
    _baseASCII = {"A": 65, "C": 67, "G": 71, "T": 84, "N": 78}
    BASE_LIST = ['A', 'C', 'G', 'T', 'N']

    def __init__(self, calFile=None):
        super(Cal, self).__init__()
        # self.code = ("A", "C", "G", "T")
        self.clear()

        if calFile:
            self.load(calFile)

    def __str__(self):
        infoList = []
        infoList.append("File:\t%s" % self.calFile)
        infoList.append("FOV:\t%s" % self.fov)
        infoList.append("DNBs:\t%d" % self.number)
        infoList.append("Cycle:\t%d" % self.totalCycle)
        if len(self.cycleSet) < self.totalCycle:
            invalid = set(range(1, self.totalCycle+1)) - self.cycleSet
            infoList.append("InvalidCycle:\t%s" % ", ".join(map(str, sorted(list(invalid)))))
        return "\n".join(infoList)

    def clear(self):
        ''' Clear the old data
        '''
        self.number = 0
        self.totalCycle = 0
        self.qual = {}
        self.basesDigit = {}
        self.bases = {}
        self.cycleSet = set()
        self.calFile = None
        self.version = 0
        self.fov = ""

    def newCycle(self, base="N", qual=0):
        ''' Create a new cycle, fill with N by default.
        '''
        newCycle = self.totalCycle + 1
        self.totalCycle += 1
        self.cycleSet.add(newCycle)
        self.qual[newCycle] = np.zeros(self.number, dtype=np.uint8) + qual
        # fill with N, ASCII 78
        self.basesDigit[newCycle] = np.zeros(self.number, dtype=np.uint8) + self._baseASCII[base]
        self.bases[newCycle] = self.basesDigit.view("S1")

    def load(self, filename, center_bool=False, swap_dyes=False):
        ''' Load the bases and quality from cal file.
        '''
        if bool(swap_dyes):
            swap_dyes = swap_dyes
        else:
            swap_dyes = False
        if type(filename) is list:
            uintArray_list = []
            for i, fname in enumerate(filename):
                if i == 0:
                    self.clear()
                self.fov = 'Full_Lane'
                with open(fname, 'rb') as fh:
                    uintArray_list.append(np.fromfile(fh, dtype=np.uint8))
                # print(uintArray)
                self.calFile = fname
                # header
                # the first 4 bytes is DNB number
                # the second 4 bytes is total cycle number
            tmpArr_list = [uintArray[:self.INT_LEN * 2] for uintArray in uintArray_list]
            for i in range(len(tmpArr_list)):
                tmpArr_list[i].dtype = np.int32
            self.number = sum([tmpArr[0] for tmpArr in tmpArr_list])
            self.number_single = tmpArr_list[0][0]
            self.totalCycle = tmpArr_list[0][1]
            # print(self.totalCycle)


            ## each cycle
            self.validCycle = set()
            idx = 8
            for c in range(self.totalCycle):
                ## The first 4 bytes is Cycle ID
                idArr = uintArray_list[0][idx:idx + self.INT_LEN]
                print(idArr)
                print(c)
                idArr.dtype = np.uint32
                try:
                    print(idArr)
                    cycleId = idArr[0]
                    end = idx + self.INT_LEN + self.number_single
                    ## extract the data region
                    dataArr = np.concatenate([uintArray[idx + self.INT_LEN: end] for uintArray in uintArray_list])
                    ## update the index pointer
                    idx = end
                except IndexError:
                    cycleId = 0
                ## 1 byte per base
                if cycleId == 0:
                    basesDigit = np.ones(self.number) * 78
                    # basesDigit[:] = self._baseASCII["N"]
                    qualArr = np.zeros(self.number, dtype=np.uint8)
                    self.cycleSet.add(c + 1)
                    self.qual[c + 1] = qualArr
                    self.basesDigit[c + 1] = basesDigit.astype(np.uint8)
                    ## view as Byte string
                    self.bases[c + 1] = basesDigit.astype(np.uint8).view("S1")
                    continue

                qualArr = np.right_shift(np.left_shift(dataArr, 2), 2)
                basesDigit = np.right_shift(dataArr, 6)
                ## translate to charater
                ## A: ACSII 65
                basesDigit += self._baseASCII["A"]
                ## T: ACSII 84
                basesDigit[np.where(basesDigit == self._baseASCII["A"] + 3)] = self._baseASCII["T"]
                ## G: ACSII 71
                basesDigit[np.where(basesDigit == self._baseASCII["A"] + 2)] = self._baseASCII["G"]
                ## C: ACSII 67
                basesDigit[np.where(basesDigit == self._baseASCII["A"] + 1)] = self._baseASCII["C"]
                ## N: ACSII 78, Noted that N is quality == 0
                basesDigit[np.where(qualArr == 0)] = self._baseASCII["N"]

                self.cycleSet.add(cycleId)
                self.qual[cycleId] = qualArr
                self.basesDigit[cycleId] = basesDigit
                ## view as Byte string
                self.bases[cycleId] = basesDigit.view("S1")
            self.version = uintArray_list[0][idx - 1]
            return
        else:
            print('loading ' + filename)
            if type(center_bool) is np.ndarray:
                self.clear()
                self.fov = self._guessFOV(filename)

                with open(filename, 'rb') as fh:
                    uintArray = np.fromfile(fh, dtype=np.uint8)
                self.calFile = filename
                # header
                # the first 4 bytes is DNB number
                # the second 4 bytes is total cycle number
                tmpArr = uintArray[:self.INT_LEN * 2]
                tmpArr.dtype = np.int32
                self.number = tmpArr[0]

                self.totalCycle = tmpArr[1]

                # each cycle
                self.validCycle = set()
                idx = 8
                for c in range(self.totalCycle):
                    # The first 4 bytes is Cycle ID
                    idArr = uintArray[idx:idx + self.INT_LEN]
                    idArr.dtype = np.int32
                    try:
                        cycleId = idArr[0]
                        end = idx + self.INT_LEN + self.number
                        # extract the data region
                        dataArr = uintArray[idx + self.INT_LEN: end]
                        # update the index pointer
                        idx = end
                    except IndexError:
                        cycleId = 0
                    # 1 byte per base

                    if cycleId == 0:
                        basesDigit = np.ones(self.number, dtype=np.uint8) * 78
                        # basesDigit[:] = self._baseASCII["N"]
                        qualArr = np.zeros(self.number, dtype=np.uint8)
                        self.cycleSet.add(c+1)
                        self.qual[c+1] = qualArr[center_bool]
                        self.basesDigit[c+1] = basesDigit[center_bool]
                        # view as Byte string
                        self.bases[c+1] = basesDigit.view("S1")[center_bool]
                        continue

                    qualArr = np.right_shift(np.left_shift(dataArr, 2), 2)
                    basesDigit = np.right_shift(dataArr, 6)
                    # translate to charater
                    # A: ACSII 65
                    if not bool(swap_dyes):
                        basesDigit += self._baseASCII["A"]
                        # T: ACSII 84
                        basesDigit[np.where(basesDigit == self._baseASCII["A"] + 3)] = self._baseASCII["T"]
                        # G: ACSII 71
                        basesDigit[np.where(basesDigit == self._baseASCII["A"] + 2)] = self._baseASCII["G"]
                        # C: ACSII 67
                        basesDigit[np.where(basesDigit == self._baseASCII["A"] + 1)] = self._baseASCII["C"]
                        # N: ACSII 78, Noted that N is quality == 0
                        basesDigit[np.where(qualArr == 0)] = self._baseASCII["N"]

                    else:
                        basesDigit += self._baseASCII["A"]
                        # T: ACSII 84
                        t_pos = np.where(basesDigit == self._baseASCII["A"] + 3)
                        g_pos = np.where(basesDigit == self._baseASCII["A"] + 2)
                        c_pos = np.where(basesDigit == self._baseASCII["A"] + 1)
                        a_pos = np.where(basesDigit == self._baseASCII["A"])
                        basesDigit[t_pos] = self._baseASCII[swap_dyes["T"]]
                        # G: ACSII 71
                        basesDigit[g_pos] = self._baseASCII[swap_dyes["G"]]
                        # C: ACSII 67
                        basesDigit[c_pos] = self._baseASCII[swap_dyes["C"]]

                        basesDigit[a_pos] = self._baseASCII[swap_dyes["A"]]
                        # N: ACSII 78, Noted that N is quality == 0
                        basesDigit[np.where(qualArr == 0)] = self._baseASCII["N"]

                    self.cycleSet.add(cycleId)
                    self.qual[cycleId] = qualArr[center_bool]
                    self.basesDigit[cycleId] = basesDigit[center_bool]
                    # view as Byte string
                    self.bases[cycleId] = basesDigit.view("S1")[center_bool]
                try:
                    self.version = uintArray[idx]
                except IndexError:
                    self.version = 'a'
                self.number = int(center_bool.sum())
                return
            else:
            # clear the old data
                self.clear()
                self.fov = self._guessFOV(filename)

                with open(filename, 'rb') as fh:
                    uintArray = np.fromfile(fh, dtype=np.uint8)
                # print(uintArray)
                self.calFile = filename
                # header
                # the first 4 bytes is DNB number
                # the second 4 bytes is total cycle number
                tmpArr = uintArray[:self.INT_LEN * 2]
                tmpArr.dtype = np.int32
                self.number = tmpArr[0]
                self.totalCycle = tmpArr[1]
                # print(self.totalCycle)

                ## each cycle
                self.validCycle = set()
                idx = 8
                for c in range(self.totalCycle):
                    ## The first 4 bytes is Cycle ID
                    idArr = uintArray[idx:idx+self.INT_LEN]
                    # print(idArr)
                    idArr.dtype = np.int32
                    try:
                        cycleId = idArr[0]
                        end = idx + self.INT_LEN + self.number
                        ## extract the data region
                        dataArr = uintArray[idx + self.INT_LEN: end]
                        ## update the index pointer
                        idx = end
                    except IndexError:
                        cycleId = 0
                    ## 1 byte per base
                    if cycleId == 0:
                        basesDigit = np.ones(self.number) * 78
                        # basesDigit[:] = self._baseASCII["N"]
                        qualArr = np.zeros(self.number, dtype=np.uint8)
                        self.cycleSet.add(c+1)
                        self.qual[c+1] = qualArr
                        self.basesDigit[c+1] = basesDigit.astype(np.uint8)
                        ## view as Byte string
                        self.bases[c+1] = basesDigit.astype(np.uint8).view("S1")
                        continue

                    qualArr = np.right_shift(np.left_shift(dataArr, 2), 2)
                    basesDigit = np.right_shift(dataArr, 6)
                    ## translate to charater
                    ## A: ACSII 65
                    if not bool(swap_dyes):
                        basesDigit += self._baseASCII["A"]
                        # T: ACSII 84
                        basesDigit[np.where(basesDigit == self._baseASCII["A"] + 3)] = self._baseASCII["T"]
                        # G: ACSII 71
                        basesDigit[np.where(basesDigit == self._baseASCII["A"] + 2)] = self._baseASCII["G"]
                        # C: ACSII 67
                        basesDigit[np.where(basesDigit == self._baseASCII["A"] + 1)] = self._baseASCII["C"]
                        # N: ACSII 78, Noted that N is quality == 0
                        basesDigit[np.where(qualArr == 0)] = self._baseASCII["N"]

                        self.cycleSet.add(cycleId)
                        self.qual[cycleId] = qualArr[center_bool]
                        self.basesDigit[cycleId] = basesDigit[center_bool]
                        # view as Byte string
                        self.bases[cycleId] = basesDigit.view("S1")[center_bool]
                    else:
                        basesDigit += self._baseASCII["A"]
                        # T: ACSII 84
                        t_pos = np.where(basesDigit == self._baseASCII["A"] + 3)
                        g_pos = np.where(basesDigit == self._baseASCII["A"] + 2)
                        c_pos = np.where(basesDigit == self._baseASCII["A"] + 1)
                        a_pos = np.where(basesDigit == self._baseASCII["A"])
                        basesDigit[t_pos] = self._baseASCII[swap_dyes["T"]]
                        # G: ACSII 71
                        basesDigit[g_pos] = self._baseASCII[swap_dyes["G"]]
                        # C: ACSII 67
                        basesDigit[c_pos] = self._baseASCII[swap_dyes["C"]]

                        basesDigit[a_pos] = self._baseASCII[swap_dyes["A"]]
                        # N: ACSII 78, Noted that N is quality == 0
                        basesDigit[np.where(qualArr == 0)] = self._baseASCII["N"]

                    self.cycleSet.add(cycleId)
                    self.qual[cycleId] = qualArr
                    self.basesDigit[cycleId] = basesDigit
                    ## view as Byte string
                    self.bases[cycleId] = basesDigit.view("S1")
                self.version = uintArray[idx-1]
                return

    def loadFromFastq(self, filename, center_bool=False):
        import gzip
        with gzip.open(filename, 'rb') as fp:
            fq_list = fp.readlines()
            # fq_list = map(list, fq_list)
        self.number = len(fq_list)/4
        self.read_len = len(fq_list[1])-2
        seq_bool = np.tile(np.array([0, 1, 0, 0], dtype=bool), self.number)
        qual_bool = np.tile(np.array([0, 0, 0, 1], dtype=bool), self.number)
        char_array = np.array(map(list, fq_list))
        bases_arr = np.array(char_array[seq_bool.tolist()].tolist()).view(np.uint8)
        qual_arr = np.array(char_array[qual_bool.tolist()].tolist()).view(np.uint8) - 33
        self.basesDigit = {}
        self.qual = {}
        for i in range(self.read_len):
            self.basesDigit[i+1] = bases_arr[:, i]
            self.qual[i+1] = qual_arr[:, i]

    def statFromFastq(self, filename, out_name, center_bool=False):
        self.fov = ''
        self.loadFromFastq(filename, center_bool=center_bool)
        self.write_fqstat_(out_name, '', 1, self.read_len, None, '')

    def _guessFOV(self, filename):
        ''' Calculate the Row and Column of FOV
            according to the file name started with
            CXXXRXXX.
            Return a tuple with (FovCol, FovRow)
        '''
        strLen = 2 * (self.FOV_CR_LEN + 1)
        base = os.path.basename(filename)
        if base[0] == "C" and base[self.FOV_CR_LEN+1] == "R":
            return os.path.basename(filename)[:strLen]
        return ""

    def get(self, cycle, idx):
        ''' Get the base and quality of specific DNB by cycle and idx.
        '''
        try:
            return (self.bases[cycle][idx].decode("utf8"), self.qual[cycle][idx])
        except KeyError:
            return None

    def getReads(self, idx):
        cycleList = sorted(list(self.cycleSet))
        baseList = [self.bases[c][idx].decode('utf8') for c in cycleList]
        qualList = [self.qual[c][idx] for c in cycleList]
        return (cycleList, baseList, qualList)

    def setBase(self, cycle, idx, base):
        ''' Set the base of specific DNB by cycle and idx.
        '''
        self.bases[cycle][idx] = np.bytes_(base)

    def setQual(self, cycle, idx, qual):
        ''' Set the quality of specific DNB by cycle and idx.
        '''
        self.qual[cycle][idx] = qual

    def maskReads(self, readsList):
        ''' Mask specific reads to N by index array.
            The base will be set to N with quality 0.
            Parameters:
                readsList:  A numpy int array of reads index.
        '''
        for i in self.cycleSet:
            self.basesDigit[i][readsList] = self._baseASCII["N"]
            self.qual[i][readsList] = 0

    def save(self, filename):
        ''' Dump the base and quality to a cal file by given file name.
        '''
        with open(filename, "wb") as fh:
            self.number.tofile(fh)
            self.totalCycle.tofile(fh)
            for i in range(self.totalCycle):
                curCycle = i + 1
                ## empty cycle
                if curCycle not in self.cycleSet:
                    np.int32(0).tofile(fh)
                    np.zeros(self.number, dtype=np.uint8).tofile(fh)
                    continue
                np.int32(curCycle).tofile(fh)
                # A
                tmpBases = self.basesDigit[curCycle] - self._baseASCII["A"]
                # C
                tmpBases[np.where(tmpBases == self._baseASCII["C"] - self._baseASCII["A"])] = 1
                # G
                tmpBases[np.where(tmpBases == self._baseASCII["G"] - self._baseASCII["A"])] = 2
                # T
                tmpBases[np.where(tmpBases == self._baseASCII["T"] - self._baseASCII["A"])] = 3
                # N
                tmpBases[np.where(tmpBases == self._baseASCII["N"] - self._baseASCII["A"])] = 0
                np.bitwise_or(np.left_shift(tmpBases, 6), self.qual[curCycle]).tofile(fh)
            self.version.tofile(fh)

    def listAll(self, cycles=None):
        try:
            if not cycles:
                listCycles = sorted(list(self.cycleSet))
            else:
                listCycles = [int(x) for x in cycles.split(",")]
            for c in listCycles:
                baseList = self.bases[c]
                qualList = self.qual[c]
                for i in range(self.number):
                    print("%d\t%d\t%s\t%d" % (c, i, baseList[i].decode("utf8"), qualList[i]))
        except OSError:
            sys.stderr.close()
            return

    def _dumpAsFq(self, fp, idPrefix="", cycles=False, strand='', insert_vect_fp=''):
        ''' Dump base and quality to file object fp in
            FASTQ format.
        '''
        if insert_vect_fp:
            insert_vect = np.abs(np.load(insert_vect_fp))
            if type(cycles) == list:
                insert_vect[np.where(insert_vect == 0)] = cycles[1]
            else:
                insert_vect[np.where(insert_vect == 0)] = cycles
            insert_vect = insert_vect.tolist()
        else:
            insert_vect = [None]*self.number
        if strand:
            strand = '/' + strand
        if type(cycles) == list:
            if idPrefix:
                idPrefix += "_"
            allBaseArr = np.empty((cycles[1]-cycles[0]+1, self.number), dtype=np.uint8)
            allQualArr = np.empty((cycles[1]-cycles[0]+1, self.number), dtype=np.uint8)
            for c in range(cycles[0], cycles[1]+1):
                ptr = c - cycles[0]
                allBaseArr[ptr] = self.basesDigit[c]
                allQualArr[ptr] = self.qual[c] + 33
            # baseChar = allBaseArr.view("S1").reshape(-1, len(self.cycleSet))
            baseChar = allBaseArr.view("S1").T
            # qualChar = allQualArr.view("S1").reshape(-1, len(self.cycleSet))
            qualChar = allQualArr.view("S1").T
            for i in range(len(baseChar)):
                fp.write("@%s%06d/%s\n" % (idPrefix, i, strand))
                # fp.write(baseChar[i][adapter_filter[i, :][:len(baseChar[i])]==False].tostring().decode("utf8"))
                fp.write(baseChar[i][:insert_vect[i]].tostring().decode("utf8"))
                fp.write("\n+\n")
                fp.write(qualChar[i][:insert_vect[i]].tostring().decode("utf8"))
                # fp.write(qualChar[i][adapter_filter[i, :][:len(baseChar[i])]==False].tostring().decode("utf8"))
                fp.write("\n")
            return
        elif type(cycles) == int:
            if idPrefix:
                idPrefix += "_"
            allBaseArr = np.empty((cycles, self.number), dtype=np.uint8)
            allQualArr = np.empty((cycles, self.number), dtype=np.uint8)
            for c in range(1, cycles+1):
                ptr = c - 1
                allBaseArr[ptr] = self.basesDigit[c]
                allQualArr[ptr] = self.qual[c] + 33
            # baseChar = allBaseArr.view("S1").reshape(-1, len(self.cycleSet))
            baseChar = allBaseArr.view("S1").T
            # qualChar = allQualArr.view("S1").reshape(-1, len(self.cycleSet))
            qualChar = allQualArr.view("S1").T
            for i in range(len(baseChar)):
                fp.write("@%s%06d/%s\n" % (idPrefix, i, strand))
                fp.write(baseChar[i][:insert_vect[i]].tostring().decode("utf8"))
                fp.write("\n+\n")
                fp.write(qualChar[i][:insert_vect[i]].tostring().decode("utf8"))
                fp.write("\n")
            return
        else:
            if idPrefix:
                idPrefix += "_"
            allBaseArr = np.empty((len(self.cycleSet), self.number), dtype=np.uint8)
            allQualArr = np.empty((len(self.cycleSet), self.number), dtype=np.uint8)
            for c in sorted(list(self.cycleSet)):
                ptr = c - 1
                allBaseArr[ptr] = self.basesDigit[c]
                allQualArr[ptr] = self.qual[c] + 33

            # baseChar = allBaseArr.view("S1").reshape(-1, len(self.cycleSet))
            baseChar = allBaseArr.view("S1").T
            # qualChar = allQualArr.view("S1").reshape(-1, len(self.cycleSet))
            qualChar = allQualArr.view("S1").T

            for i in range(len(baseChar)):
                fp.write("@%s%06d/%s\n" % (idPrefix, i, strand))
                fp.write(baseChar[i].tostring().decode("utf8"))
                fp.write("\n+\n")
                fp.write(qualChar[i].tostring().decode("utf8"))
                fp.write("\n")
            return

    def writefq(self, filename, idPrefix=None, cycles=[[1, 50], [51, 100]], insert_vect=''):
        ''' Save the base and quality to a FASTQ file.
            Compression if filename is *.gz.
        '''
        print('writing ' + filename)
        if not idPrefix:
            idPrefix = self.fov
        if filename.endswith('.gz'):
            import gzip
            if type(cycles) is list:
                tag = 1
                if type(cycles[0]) is int:
                    tag = ''
                    suffix = '.fq.gz'
                    split_name = filename.replace('.fq.gz', suffix)
                    with gzip.open(split_name, 'wb') as fp:
                        self._dumpAsFq(fp, idPrefix=idPrefix, cycles=cycles, strand='', insert_vect_fp=insert_vect)
                else:
                    strand = 1
                    for read_bounds in cycles:
                        suffix = '_' + str(tag) + '.fq.gz'
                        split_name = filename.replace('.fq.gz', suffix)
                        with gzip.open(split_name, 'wb') as fp:
                            self._dumpAsFq(fp, idPrefix=idPrefix, cycles=read_bounds, strand=str(strand),
                                           insert_vect_fp=insert_vect)
                        tag += 1
                        strand += 1
            elif type(cycles) == int:
                with gzip.open(filename, 'wb') as fp:
                    self._dumpAsFq(fp, idPrefix=idPrefix, cycles=cycles, strand='', insert_vect_fp=insert_vect)
            else:
                with gzip.open(filename, 'wb') as fp:
                    self._dumpAsFq(fp, idPrefix=idPrefix, strand='', insert_vect_fp=insert_vect)
        else:
            with open(filename, "w", 100000000) as fp:
                self._dumpAsFq(fp, idPrefix=idPrefix, strand='', insert_vect_fp=insert_vect)
        return

    # def trim_adapter(self, adapter_seq):
    #     this function creates a guide array to remove certain bases from dnbs if they are from the adapter
    #     this method of trimming will not catch reads where the adapter is within the read surround by non adapter
    #     sequences. Consequently this funtion is best use to detect prepended adapters not appended ones that may
    #     have sequences reading beyond
    #     self.adapter_mat = np.zeros((len(self.bases.keys()), len(self.bases[1])), dtype=bool)
    #
    #     max_base = max(self.bases.keys())
    #     under_consideration = np.ones(len(self.bases[1]))
    #     k = 0
    #     while under_consideration.sum() > 0:
    #         i = 1
    #         thresh = int(float(len(adapter_seq))*0.9)
    #         for j, base in enumerate(adapter_seq[k:-(k+1)]):
    #             if j < 1:
    #                 self.adapter_mat[j, under_consideration] = (self.bases[i][under_consideration] == base)
    #                 self.adapter_mat[-i, under_consideration] = \
    #                     (self.bases[max_base-j][under_consideration] == adapter_seq[-i])
    #             else:
    #                 self.adapter_mat[j, [under_consideration]] = \
    #                     ((self.bases[i][under_consideration] == base) & self.adapter_mat[j-1, under_consideration])
    #                 self.adapter_mat[-i, under_consideration] = \
    #                     ((self.bases[max_base - j][under_consideration] == adapter_seq[-i]) &
    #                      self.adapter_mat[-i+1, under_consideration])
    #             i += 1
    #         self.adapter_mat[0] = (self.adapter_mat[0, :] & self.adapter_mat[1, :])
    #         self.adapter_mat[-1] = (self.adapter_mat[-1, :] & self.adapter_mat[-2, :])
    #         under_consideration[np.where(self.adapter_mat.sum(0) > thresh)] = False
    #         k += 1
    #     Adapter_matches = (self.adapter_mat.sum(axis=0) >= int(float(len(adapter_seq))*0.9))
    #     i = 1
    #     for i, key in enumerate(self.bases.keys()):
    #         self.adapter_mat[i, Adapter_matches == False] = False
    #     for j in range(len(adapter_seq)):
    #         self.bases[i][self.adapter_mat[j]] = ''

    # def seq2kmer(self, text, n=7):
    #     return [text[i:i + n] for i in range(len(text) - n + 1)]

    def write_fqstat(self, fq_dir, fov, cycles, subset_labels, center=False):
        cycle_start = 1
        extension = 1
        if not subset_labels:
            if len(cycles) == 2:
                if type(cycles[0]) is int:
                    cycle_start = cycles[0]
                    cycle_stop = cycles[1] + 1
                    fqstat = os.path.join(fq_dir, fov + '.fq.fqStat.txt')
                    self.write_fqstat_(fqstat, fov, cycle_start, cycle_stop)
                    extension += 1
                else:
                    for cycle in cycles:
                        cycle_start = cycle[0]
                        cycle_stop = cycle[1] + 1
                        fqstat = os.path.join(fq_dir, fov + '_' + str(extension) + '.fq.fqStat.txt')
                        self.write_fqstat_(fqstat, fov, cycle_start, cycle_stop)
                        extension += 1

            else:
                cycle_stop = cycles[0] + 1
                fqstat = os.path.join(fq_dir, fov + '.fq.fqStat.txt')
                self.write_fqstat_(fqstat, fov, cycle_start, cycle_stop)
        else:
            for subset_label in subset_labels:
                subset_vect = np.load(os.path.join(fq_dir, fov + subset_label +'.npy'))
                cycle_start = 1
                extension = 1
                if len(cycles) == 2:
                    if type(cycles[0]) is int:
                        # print (cycles)
                        cycle_stop = cycles[1] + 1
                        cycle_start = cycles[0]
                        suffix = '_' + fov  + '.fq.fqStat.txt'
                        self.write_fqstat_(fq_dir, suffix, cycle_start, cycle_stop, subset_vect, subset_label)
                        extension += 1
                    else:
                        for cycle in cycles:
                            cycle_stop = cycle[1] + 1
                            cycle_start = cycle[0]
                            suffix = '_' + fov + '_' + str(extension) + '.fq.fqStat.txt'
                            self.write_fqstat_(fq_dir, suffix, cycle_start, cycle_stop, subset_vect, subset_label)
                            extension += 1
                else:
                    cycle_stop = cycles[0]
                    suffix = '_' + fov + '.fq.fqStat.txt'
                    self.write_fqstat_(fq_dir, suffix, cycle_start, cycle_stop, subset_vect, subset_label)
            cycle_start = 1
            extension = 1
            if len(cycles) == 2:
                if type(cycles[0]) is int:
                    cycle_start = cycles[0]
                    cycle_stop = cycles[1] + 1
                    fqstat = os.path.join(fq_dir, fov + '.fq.fqStat.txt')
                    self.write_fqstat_(fqstat, fov, cycle_start, cycle_stop)
                    extension += 1
                else:
                    for cycle in cycles:
                        cycle_start += cycle[0]
                        cycle_stop = cycle[1] + 1
                        fqstat = os.path.join(fq_dir, fov + '_' + str(extension) + '.fq.fqStat.txt')
                        self.write_fqstat_(fqstat, fov, cycle_start, cycle_stop)
                        extension += 1
            else:
                cycle_stop = cycles[1] + 1
                fqstat = os.path.join(fq_dir, fov + '.fq.fqStat.txt')
                self.write_fqstat_(fqstat, fov, cycle_start, cycle_stop)

    def getESRFilter(self, cycles=[1, 102], esr_vect_path=None, blocks=None, blocks_out_path='Block_ESR_Array.npy'):
        esr_vals = []
        if type(cycles[0]) is int:
            self.esr_filter_vect = np.ones_like(self.qual[cycles[0]]).astype(bool)
            dnb_count = float(len(self.esr_filter_vect))
            for i, cycle in enumerate(cycles):
                esr_filter_temp = np.zeros_like(self.qual[cycles[0]])
                for j in range(15):
                    if i == 0:
                        esr_filter_temp += (self.qual[cycle + j] < 20)
                    else:
                        esr_filter_temp += (self.qual[cycle + j] < 10)
                esr_vals.append(round(100.0*float((esr_filter_temp <= 2).sum())/dnb_count, 2))
                esr_filter_temp = (esr_filter_temp > 2)
                self.esr_filter_vect[esr_filter_temp] = False

        else:
            self.esr_filter_vect = np.ones_like(self.qual[1])
            dnb_count = float(len(self.esr_filter_vect))
            for i, cycle in enumerate(cycles):
                esr_filter_temp = np.zeros_like(self.qual[cycle[0]])
                for j in range(15):
                    if i == 0:
                        esr_filter_temp += (self.qual[cycle[0] + j] < 20)
                    else:
                        esr_filter_temp += (self.qual[cycle[0] + j] < 10)
                esr_vals.append(round(100.0 * float((esr_filter_temp <= 2).sum()) / dnb_count, 2))
                esr_filter_temp = (esr_filter_temp > 2)
                self.esr_filter_vect[esr_filter_temp] = False

        if bool(esr_vect_path):
            np.save(esr_vect_path, self.esr_filter_vect)
        if bool(blocks):
            if (type(blocks) is str) and os.path.isfile(blocks):
                if blocks.endswith('.txt'):
                    pos_data = np.loadtxt(blocks, delimiter='\t')
                    blocks_vect = pos_data[:, 1].astype(int)
                if blocks.endswith('.npy'):
                    blocks_vect=  np.load(blocks).astype(int)

            elif type(blocks) is np.ndarray:
                blocks_vect = blocks
            elif type(blocks) is list:
                blocks_vect = np.array(blocks)
            else:
                print('Blocks variable type is incompatible')
                blocks_vect = False
                esr = 100.0 * (float(self.esr_filter_vect.sum()) / float(len(self.esr_filter_vect)))
                esr = round(esr, 2)
                return esr
            block_arr = np.zeros((len(np.unique(blocks_vect)), 2))
            block_arr[:, 0] = np.unique(blocks_vect)
            for i, block in enumerate(block_arr[:, 0]):
                block_arr[i, 1] = 100.0*(float(self.esr_filter_vect[np.where(blocks_vect == block)].sum()) /
                                         float((blocks_vect == block).sum()))
            np.save(blocks_out_path, block_arr)
        esr = 100.0 * (float(self.esr_filter_vect.sum()) / float(len(self.esr_filter_vect)))
        esr_filter_val = round(esr, 2)
        return esr_filter_val, esr_vals


    def write_fqstat_(self, fq_path, suffix, cycle_start, cycle_stop, subset_vect=None, subset_label=''):
        if type(subset_vect) is not np.ndarray:
            fqstat_fp = fq_path
            self.naming_dict = {}
            self.naming_dict['fov'] = self.fov
            base_scores_total = float((cycle_stop-cycle_start)*self.number)
            base_count = float((cycle_stop-cycle_start)*self.number)
            N_count = float(sum([(self.basesDigit[cycle] == self._baseASCII['N']).sum()
                                 for cycle in range(cycle_start, cycle_stop)]))
            N_perc = N_count / base_count * 100.0 if base_count else 0.0
            non_N_count = base_count - N_count
            # sum scores, sum G+C, sum cycles
            GC_count = float(sum([((self.basesDigit[cycle] == self._baseASCII['C']) |
                                   (self.basesDigit[cycle] == self._baseASCII['G'])).sum()
                                  for cycle in range(cycle_start, cycle_stop)]))
            GC_perc = round(GC_count / non_N_count * 100.0, 2) if non_N_count else 0.0
            Q10_perc = round(sum([(self.qual[cycle_index] >= 10).sum()
                                  for cycle_index in range(cycle_start, cycle_stop)])
                             / base_count * 100.0, 2) if base_count else 0.0
            Q20_perc = round(sum([(self.qual[cycle_index] >= 20).sum()
                                  for cycle_index in range(cycle_start, cycle_stop)])
                             / base_count * 100.0, 2) if base_count else 0.0
            Q30_perc = round(sum([(self.qual[cycle_index] >= 30).sum()
                                  for cycle_index in range(cycle_start, cycle_stop)])
                             / base_count * 100.0, 2) if base_count else 0.0
            Q40_perc = round(sum([(self.qual[cycle_index] >= 40).sum()
                                  for cycle_index in range(cycle_start, cycle_stop)])
                             / base_count * 100.0, 2) if base_count else 0.0
            # Calculate estimate error percentage (eep)
            # for each cycle now (to calculate overall avg), and store for later
            eep_list = []
            for cycle_index in range(cycle_start, cycle_stop):
                score_count_row = map(int,
                                      [(self.qual[cycle_index] == score).sum() for
                                       score in
                                       range(42)])
                eep = scores2discordance(score_count_row)
                eep_list.append(eep)
            eep_avg = round(sum(eep_list) / len(eep_list), 4) if eep_list else 0.0

            with open(fqstat_fp, 'w') as stat_f:
                stat_csv = csv.writer(stat_f, delimiter='\t', lineterminator='\r\n')
                stat_csv.writerow(['#Name', '%(fov)s.fq' % self.naming_dict])
                stat_csv.writerow(['#PhredQual', '33'])
                stat_csv.writerow(['#ReadNum', self.number])
                stat_csv.writerow(['#row_readLen', (cycle_stop-cycle_start)])
                stat_csv.writerow(['#col', 48])
                stat_csv.writerow(['#BaseNum', int(base_count)])
                stat_csv.writerow(['#N_Count', N_count, N_perc])
                stat_csv.writerow(['#GC%', GC_perc])
                stat_csv.writerow(['#>Q10%', Q10_perc])
                stat_csv.writerow(['#>Q20%', Q20_perc])
                stat_csv.writerow(['#>Q30%', Q30_perc])
                stat_csv.writerow(['#>Q40%', Q40_perc])
                stat_csv.writerow(['#EstErr%', eep_avg])

                pos_row = ['#Pos'] + self.BASE_LIST + \
                          range(42) + ['%s_Err%%' % base for base in self.BASE_LIST] + ['Err%']
                stat_csv.writerow(pos_row)
                for i, cycle_index in enumerate(range(cycle_start, cycle_stop)):
                    position_number = i + 1
                    base_count_row = [(self.basesDigit[cycle_index] == self._baseASCII[base]).sum()
                                      for base in self.BASE_LIST]
                    score_count_row = [(self.qual[cycle_index] == score).sum() for score in range(42)]
                    base_eeps = map(scores2discordance, [map(int, [(self.qual[cycle_index][self.basesDigit[cycle_index]
                                                                                           == self._baseASCII[base]] ==
                                                                    score).sum() for score in range(42)])
                                                         for base in self.BASE_LIST])
                    eep = eep_list[i]
                    pos_row = [position_number] + base_count_row + score_count_row + base_eeps + [eep]
                    stat_csv.writerow(pos_row)
            return
        else:
            for subset_ind in np.unique(subset_vect):
                fqstat_fp = os.path.join(fq_path, subset_label[1:] + '-' + str(int(subset_ind)) + suffix)
                self.naming_dict = {}
                self.naming_dict['fov'] = self.fov
                subset_dnbs = np.where(subset_vect == subset_ind)
                subset_read_count = int(len(subset_dnbs[0]))
                base_scores_total = float((cycle_stop - cycle_start) * subset_read_count)
                base_count = float((cycle_stop - cycle_start) * subset_read_count)
                N_count = float(sum([(self.basesDigit[cycle][subset_dnbs] == self._baseASCII['N']).sum()
                                     for cycle in range(cycle_start, cycle_stop)]))
                N_perc = N_count / base_count * 100.0 if base_count else 0.0
                non_N_count = base_count - N_count
                # sum scores, sum G+C, sum cycles
                GC_count = float(sum([((self.basesDigit[cycle][subset_dnbs] == self._baseASCII['C']) |
                                       (self.basesDigit[cycle][subset_dnbs] == self._baseASCII['G'])).sum()
                                      for cycle in range(cycle_start, cycle_stop)]))
                GC_perc = round(GC_count / non_N_count * 100.0, 2) if non_N_count else 0.0
                Q10_perc = round(sum([(self.qual[cycle_index][subset_dnbs] >= 10).sum()
                                      for cycle_index in range(cycle_start, cycle_stop)])
                                 / base_count * 100.0, 2) if base_count else 0.0
                Q20_perc = round(sum([(self.qual[cycle_index][subset_dnbs] >= 20).sum()
                                      for cycle_index in range(cycle_start, cycle_stop)])
                                 / base_count * 100.0, 2) if base_count else 0.0
                Q30_perc = round(sum([(self.qual[cycle_index][subset_dnbs] >= 30).sum()
                                      for cycle_index in range(cycle_start, cycle_stop)])
                                 / base_count * 100.0, 2) if base_count else 0.0
                Q40_perc = round(sum([(self.qual[cycle_index][subset_dnbs] >= 40).sum()
                                      for cycle_index in range(cycle_start, cycle_stop)])
                                 / base_count * 100.0, 2) if base_count else 0.0
                # Calculate estimate error percentage (eep) for each cycle now (to calculate overall avg),
                # and store for later
                eep_list = []
                for cycle_index in range(cycle_start, cycle_stop):
                    score_count_row = map(int,
                                          [(self.qual[cycle_index][subset_dnbs] == score).sum() for
                                           score in
                                           range(42)])
                    eep = scores2discordance(score_count_row)
                    eep_list.append(eep)
                eep_avg = round(sum(eep_list) / len(eep_list), 4) if eep_list else 0.0
                if not os.path.isfile(fqstat_fp):
                    with open(fqstat_fp, 'w') as stat_f:
                        stat_csv = csv.writer(stat_f, delimiter='\t', lineterminator='\r\n')
                        stat_csv.writerow(['#Name', '%(fov)s.fq' % self.naming_dict])
                        stat_csv.writerow(['#PhredQual', '33'])
                        stat_csv.writerow(['#ReadNum', subset_read_count])
                        stat_csv.writerow(['#row_readLen', (cycle_stop - cycle_start)])
                        stat_csv.writerow(['#col', 48])
                        stat_csv.writerow(['#BaseNum', int(base_count)])
                        stat_csv.writerow(['#N_Count', N_count, N_perc])
                        stat_csv.writerow(['#GC%', GC_perc])
                        stat_csv.writerow(['#>Q10%', Q10_perc])
                        stat_csv.writerow(['#>Q20%', Q20_perc])
                        stat_csv.writerow(['#>Q30%', Q30_perc])
                        stat_csv.writerow(['#>Q40%', Q40_perc])
                        stat_csv.writerow(['#EstErr%', eep_avg])
                        pos_row = ['#Pos'] + self.BASE_LIST + range(42) + ['%s_Err%%' % base for base in self.BASE_LIST] \
                                  + ['Err%']
                        stat_csv.writerow(pos_row)
                        for i, cycle_index in enumerate(range(cycle_start, cycle_stop)):
                            position_number = i + 1
                            base_count_row = [(self.basesDigit[cycle_index][subset_dnbs] == self._baseASCII[base]).sum()
                                              for base in self.BASE_LIST]
                            score_count_row = [(self.qual[cycle_index][subset_dnbs] == score).sum() for score in range(42)]
                            base_eeps = map(scores2discordance,
                                            [map(int, [(self.qual[cycle_index][subset_dnbs][
                                                            self.basesDigit[cycle_index][subset_dnbs] ==
                                                            self._baseASCII[base]] ==
                                                        score).sum() for score in range(42)])
                                             for base in self.BASE_LIST])
                            eep = eep_list[i]
                            pos_row = [position_number] + base_count_row + score_count_row + base_eeps + [eep]
                            stat_csv.writerow(pos_row)
            return

    def cmp(self, oth):
        if not type(oth) is self.__class__ or self.number != oth.number:
            return None
        cmp_result = {}
        for c in sorted(list(self.cycleSet)):
            if c in oth.cycleSet:
                sameNum = (self.basesDigit[c] == oth.basesDigit[c]).sum()
                curN = (self.basesDigit[c] == self._baseASCII["N"])
                othN = (oth.basesDigit[c] == self._baseASCII["N"])
                bothN = np.logical_and(curN, othN).sum()
                eithN = np.logical_xor(curN, othN).sum()
                cmp_result[c] = {"match": sameNum - bothN, "mismatch": self.number - sameNum - eithN}
        return cmp_result


##########################################################################
#  BEGIN Function  ############################
##########################################################################


######################################################################
#  BEGIN Main  ############################
######################################################################
#################################
##
#  Main function of program.
##
#################################
def main():

    # Phrase parameters #########################
    import argparse
    arg_parser = argparse.ArgumentParser(usage=usage)
    arg_parser.add_argument("--version", action="version", version=PROG_VERSION)
    arg_parser.add_argument("-q", "--fq", action="store", dest="fq", default=None, metavar="FILE",
                            help="Dump cal into fq file. [%(default)s]")
    arg_parser.add_argument("-d", "--dnb", action="store", dest="dnbPos", type=int, default=None, metavar="INDEX CYCLE",
                            nargs="+", help="Display select DNB by index and cycle . [%(default)s]")
    arg_parser.add_argument("-c", "--cmp", action="store", dest="cmpCal", default=None, metavar="CALFILE",
                            help="Compare to another cal file. [%(default)s]")
    arg_parser.add_argument("-l", "--list", action="store_true", dest="listfile", default=False,
                            help="List all bases and qualities of cal file. [%(default)s]")
    arg_parser.add_argument("--cycle", action="store", dest="listCycles", default=None, metavar="CYCLES",
                            help="Cycles to list, separated by comma. [%(default)s]")

    (para, args) = arg_parser.parse_known_args()

    if len(args) != 1:
        arg_parser.print_help()
        print("\nERROR: The parameters number is not correct!")
        sys.exit(1)
    else:
        (calFile,) = args

    # Main Body #############################
    cal = Cal(calFile)
    if para.fq:
        cal.writefq(para.fq)
    elif para.dnbPos:
        if len(para.dnbPos) == 1:
            res = cal.getReads(para.dnbPos[0])
            for v in zip(*res):
                print("%d\t%s\t%d" % v)
        else:
            res = cal.get(para.dnbPos[1], para.dnbPos[0])
            print("%d\t%s\t%s" % (para.dnbPos[1], res[0], res[1]))
    elif para.cmpCal:
        oth = Cal(para.cmpCal)
        res = cal.cmp(oth)
        print("#Cycle\tMatch\tMismatch\tMisRate%")
        for c in sorted(list(cal.cycleSet)):
            try:
                print("%d\t%d\t%d\t%.2f" % (c, res[c]["match"], res[c]["mismatch"],
                                            100*res[c]["mismatch"]/res[c]["match"]))
            except ZeroDivisionError:
                print("%d\t%d\t%d\t0" % (c, res[c]["match"], res[c]["mismatch"]))
    elif para.listfile:
        cal.listAll(para.listCycles)
    else:
        print(cal)
    # cal.writefq("new.fq.gz")
    # cal.convertFq(1)


#################################
##
#   Start the main program.
##
#################################
if __name__ == '__main__':
    main()

# God's in his heaven, All's right with the world. ##################
